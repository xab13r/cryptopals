'''

Matasano Crypto Challenges
Set 02 - Challenge 14

BYTE-AT-A-TIME ECB DECRYPTION (HARD)

'''

import base64
from Crypto.Random import get_random_bytes
from Crypto.Random.random import randint
from set02challenge11 import ecb_module

global random_prefix
random_prefix = get_random_bytes(randint(1, 32))


def encryption_oracle(plaintext):
    global random_key
    random_key = get_random_bytes(16)

    encoded_suffix = base64.b64decode(
        'Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkgaGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBqdXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUgYnkK')

    expanded_plaintext = random_prefix + plaintext + encoded_suffix

    cipher_ecb = ecb_module()
    ciphertext = cipher_ecb.ecb_encrypt(expanded_plaintext, random_key)

    return ciphertext


def find_blocksize(encryption_oracle):
    # An empty string will force the oracle to apply padding to the encoded suffix to fill an unknown number of blocks with a length that can be defined as:
    length_of_null_string = len(encryption_oracle(b''))
    i = 1
    # Let's feed one byte at-a-time to the encryption oracle, until a new block is created. The difference between the ciphertext generated by a null string and the one that will force the creation of a new block will yield the blocksize
    while True:
        plaintext = bytes([0] * i)
        ciphertext = encryption_oracle(plaintext)
        if len(ciphertext) != length_of_null_string:
            return len(ciphertext) - length_of_null_string
        i += 1


def determine_ecb(blocksize):

    # Feed six blocks of 0x0 bytes to the oracle
    six_plaintext = bytes([0]*blocksize*6)
    six_ciphertext = encryption_oracle(six_plaintext)

    # Create a list of blocks
    cipher_blocks = slice_blocks(six_ciphertext, blocksize)

    # If duplicates are present in the list of blocks encryption oracle is using ECB encryption mode
    for i in range(0, len(cipher_blocks)-1):
        if cipher_blocks[i] == cipher_blocks[i + 1]:
            print("Encryption Oracle is using ECB")
            return True


def slice_blocks(string, blocksize):
    return [string[i:i+blocksize] for i in range(0, len(string), blocksize)]


def determine_prefix_length():
    plaintext_lenght = 32
    while True:
        # Generate a blank plaintext to find out the length of the prefix
        plaintext = bytes(b'A' * plaintext_lenght)
        # Feed the plaintext to the encryption oracle
        ciphertext = encryption_oracle(plaintext)
        # Slice the ciphertext into blocks
        cipher_blocks = slice_blocks(ciphertext, 16)

        # Analyze 2 consecutive blocks of the ciphertext. As soon as 2 blocks are equal, it means that the prefix has been added enough bytes to force an overflow into the second block. Calculating plaintext % blocksize will give the length of the prefix and the index will indicate the first block controlled by the attacker.
        for i in range(len(cipher_blocks) - 1):
            if cipher_blocks[i] == cipher_blocks[i+1]:
                return (len(plaintext) % 16, i)
        plaintext_lenght += 1


def determine_plaintext_length():
    plaintext = b''
    empty_ciphertext_length = len(encryption_oracle(plaintext))
    # Max length of the plaintext is at least the length of the empt ciphertext + 1 byte of padding
    max_plaintext_length = empty_ciphertext_length - 1

    while True:
        # Expanding plaintext one-byte-at-a-time
        plaintext += b'0'
        # Feeding encryption oracle and calculating length of ciphertext
        current_ciphertext = encryption_oracle(plaintext)
        current_ciphertext_length = len(current_ciphertext)
        # If the length of the ciphertext hasn't changed, then the padding on the plaintext is longer than 1 byte. Reduce length of plaintext and iterate
        if current_ciphertext_length == empty_ciphertext_length:
            max_plaintext_length -= 1
        else:
            return max_plaintext_length


def find_next_byte(blocksize):
    # Determine number of bytes needed to create a new block after prefix
    push_prefix_bytes, controlled_block = determine_prefix_length()
    # Determine target plaintext length
    target_plaintext_length = determine_plaintext_length() + push_prefix_bytes - \
        controlled_block * 16

    # Initialize variable for known bytes
    known_bytes = b''

    # This is gonna be a loop
    while True:
        # Create a string short of the length of known bytes (starting with one)
        string_short = bytes(
            [0]*(push_prefix_bytes + (blocksize - 1) - (len(known_bytes) % blocksize)))
        # Initialize dictionary for storing encrypted strings
        one_byte_dictionary = {}
        # Loop through all the 256 characters
        for i in range(256):
            # Encrypt shortened string | known bytes | character
            ciphertext = encryption_oracle(
                string_short + known_bytes + bytes([i]))
            # Get first block of the encrypted string and add to the dictionary
            one_byte_dictionary[ciphertext[0:len(
                string_short) + len(known_bytes) + 1]] = i
        # Encrypt the shortened string
        ciphertext_short = encryption_oracle(string_short)
        # Get first block on the encrypted shortened string
        ciphertext_sliced = ciphertext_short[0: len(
            string_short) + len(known_bytes) + 1]
        # Check for a match in the dictionary; if found, add the character to the known_bytes string
        if ciphertext_sliced in one_byte_dictionary:
            known_bytes += bytes([one_byte_dictionary[ciphertext_sliced]])
        # Break the loop as soon as no match is found inside the dictionary
        else:
            return known_bytes

    return known_bytes


def main():
    print("Finding blocksize...")
    blocksize = find_blocksize(encryption_oracle)
    print("Found blocksize:", blocksize)
    print("Checking for ECB mode encryption...")
    is_ecb = determine_ecb(blocksize)
    if is_ecb:
        print("Determining Prefix length and first controlled block...")
        prefix_length, controlled_block = determine_prefix_length()
        print("Prefix length:", 16*controlled_block - prefix_length)
        print("First controlled block:", controlled_block)
        print("Continue...")
        max_plaintext_length = determine_plaintext_length()
        known_bytes = find_next_byte(blocksize)
        print(known_bytes)
    else:
        raise Exception("--- Encryption Oracle is not using ECB ---")


if __name__ == "__main__":
    main()
